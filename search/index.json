[{"content":"字面量（Literals） 字面量是程序中直接表示固定值的数据。Python 中常见的字面量包括:\n字符串字面量：\u0026ldquo;Hello, World!\u0026rdquo; 或 \u0026lsquo;Hello, World!\u0026rsquo; 整数字面量：10, -20, 0 浮点数字面量：3.14, -0.001 布尔字面量：True, False None 字面量：None，表示空值 注释（Comments） 单行注释 以 # 开头的注释，注释掉一行内的内容。\n1 use_comment = True # 是否使用注释 多行注释 用三引号（''' 或 \u0026quot;\u0026quot;\u0026quot;）包围的注释，通常用于文档注释或解释长段代码。\n1 2 3 4 \u0026#34;\u0026#34;\u0026#34; 这是一个多行注释，可以写多行内容。 通常用于函数或类的文档说明。 \u0026#34;\u0026#34;\u0026#34; 数据类型（Data Types） 基本数据类型 类型 说明 整数(int) 整数，例如 10, -5 浮点型(float) 浮点数，例如 3.14, 0.001 字符串(str) 字符串，例如 \u0026ldquo;hello\u0026rdquo; 布尔(bool) 布尔值，True 或 False 复合数据类型 类型 说明 列表(list) 列表，存储有序可变的元素集合，例如 [1, 2, 3] 元组(tuple) 元组，存储有序不可变的元素集合，例如 (1, 2, 3) 集合(set) 集合，存储无序不重复元素，例如 {1, 2, 3} 字典(dict) 字典，存储键值对，例如 {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;xx\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: xx} 1 2 3 4 5 number = 10 # 整数类型 temperature = 98.6 # 浮点数类型 is_int = False # 布尔类型 colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;] # 列表 person = {\u0026#34;name\u0026#34;: \u0026#34;xx\u0026#34;, \u0026#34;age\u0026#34;: 0} # 字典 参考文章 Python 文档 Y 分钟速成 Python Python 官网 Python3 备忘清单 ","date":"2024-09-20T13:27:49+08:00","permalink":"https://xnuyoah.github.io/p/python-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"python 基础 - 数据类型"},{"content":"变量/常量 1 2 3 4 5 // 变量 let num = 1; // 常量 const PI = 3.14; 数据类型 字符串类型 string 1 let str = \u0026#34;string\u0026#34;; 数值类型 number ES6 不区分整型和浮点型, 所有数字都使用 number 类型 1 let num = 10; 布尔类型 boolean 1 let flag = true; 对象 object 1 2 3 let obj = { attr: \u0026#34;obj attr\u0026#34;, }; 有序集合 map 1 2 3 4 let cat = new Map([ \u0026#34;name\u0026#34;:\u0026#34;cat\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;white\u0026#34; ]) 无序且唯一集合 set 1 let numSet = new Set([1, 2, 3]); 数组 array 1 let arr = [1, 2, 3]; 函数 function 1 2 3 function func() { return \u0026#34;func\u0026#34;; } 类 class 1 2 3 4 5 6 7 8 class Obj { constructor(attr) { this.attr = attr; } } let obj = new Obj(\u0026#34;attr\u0026#34;); console.log(obj); 函数 普通函数 1 function func() {} 匿名函数 1 const func = function () {}; 箭头函数 1 const func = (x) =\u0026gt; x; 自执行函数 1 (() =\u0026gt; {})(); 数组 1 let arr = [1, 2, 3, 4, 5, 6]; push - 末尾添加并返回修改后数组长度 1 arr.push(7, 8); unshift - 首位添加并返回修改后数组长度 1 arr.unshift(0); shift - 删除第一个元素并返回被删除元素 1 arr.shift(); pop - 删除最后一个元素并返回被删除元素 1 arr.pop(); reverse - 反转 1 arr.reverse(); sort - 按首字母排序\n数字 - arr.sort((x, y) =\u0026gt; x - y)\n1 arr.sort(); filter - 筛选符合条件的元素 1 2 3 arr.filter((value, index) =\u0026gt; { return value \u0026gt; 5; }); concat - 多个数组/值合并 1 arr.concat(arr, 11, 12); for...of - 遍历数组 1 2 3 for (let elem of arr) { console.log(\u0026#34;elem -\u0026gt; \u0026#34;, elem); } forEach - 遍历 1 2 3 arr.forEach((value, index) =\u0026gt; { console.log(\u0026#34;index -\u0026gt; \u0026#34;, index, \u0026#34;value -\u0026gt; \u0026#34;, value); }); Set 集合 创建 1 let mySet = new Set([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]); 添加 - add 1 mySet.add(\u0026#34;d\u0026#34;); 删除 - delete 1 mySet.delete(\u0026#34;a\u0026#34;); 是否存在 - has 1 mySet.has(\u0026#34;b\u0026#34;); 大小 - size 1 mySet.size; 转数组 - Array.from 1 let arr = Array.from(mySet); 扩展运算符 - ... 1 2 let myStr = \u0026#34;string\u0026#34;; console.log([...myStr]); // [\u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, ...] for...of 1 2 3 for (let elem of mySet) { console.log(\u0026#34;elem -\u0026gt; \u0026#34;, elem); } forEach 1 2 3 mySet.forEach((value) =\u0026gt; { console.log(\u0026#34;v -\u0026gt; \u0026#34;, value); }); 清空 1 mySet.clear(); 去重 1 2 let arr = [1, 1, 1, 3, 2]; let arrSet = new Set(arr); Map 集合 创建 1 let myMap = new Map([\u0026#34;type\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;attr\u0026#34;: \u0026#34;attr\u0026#34;]); 添加 - set 1 myMap.set(\u0026#34;kind\u0026#34;, \u0026#34;cat\u0026#34;); 删除 - delete 1 myMap.delete(\u0026#34;type\u0026#34;); 是否包含 - has 1 myMap.has(\u0026#34;kind\u0026#34;); 大小 - size 1 myMap.size; 展开转成数组 1 console.log([...myMap]); for...of 1 2 3 for (let [k, v] of myMap) { console.log(\u0026#34;k -\u0026gt; \u0026#34;, k, \u0026#34;v -\u0026gt;\u0026#34;, v); } forEach 1 2 3 myMap.forEach((value, key) =\u0026gt; { console.log(\u0026#34;forEach\u0026#34;, key, value); }); 清空 - clear 1 myMap.clear(); 对象 创建 1 2 3 4 let obj = { attr: \u0026#34;attr\u0026#34;, function: \u0026#34;function\u0026#34;, }; 设置属性值 1 obj.size = 0; 获取属性 1 console.log(obj.attr); 删除属性 1 delete obj.size; 是否包含 1 console.log(\u0026#34;function\u0026#34; in obj); 属性数量 1 Object.keys(obj).length; 转数组 1 Object.entries(obj); for...in for...of 用于遍历可迭代对象 [如数组、Set、Map、字符串等] for...in 用于遍历对象的可枚举属性 1 2 3 for (let key in obj) { console.log(\u0026#34;key -\u0026gt; \u0026#34;, key); } forEach 1 2 3 Object.entries(obj).forEach(([value, key]) =\u0026gt; { console.log(\u0026#34;forEach\u0026#34;, key, value); }); 清空 1 obj = {}; 类、模板字符串 创建 1 2 3 4 5 6 7 8 9 10 11 12 13 class Animal { constructor(kind, color) { this.kind = kind; this.color = color; } info() { return `${kind}\u0026#39;s color is ${color}`; } } let cat = new Animal(\u0026#34;cat\u0026#34;, \u0026#34;white\u0026#34;); console.log(cat.info()); 私有变量、存取器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Animal { kind; #color; constructor(kind, color) { this.kind = kind; this.color = color; } get color() { return this.#color; } set color(value) { this.#color = value; } info() { return `${kind}\u0026#39;s color is ${color}`; } } let cat = new Animal(\u0026#34;cat\u0026#34;, \u0026#34;white\u0026#34;); cat.color = \u0026#34;black\u0026#34;; console.log(cat.info()); 继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Dog extends Animal { area; constructor(kind, color, area) { super(kind, color); this.area = area; } location() { return this.area; } } let dog = new Dog(\u0026#34;dog\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;cn\u0026#34;); console.log(dog.location()); console.log(dog.info()); 解构 数组解构 1 2 3 4 5 let [x, y] = [1, 2]; console.log(x, y); // 1, 2 let [, , x] = [1, 2, 3]; console.log(x); // 3 扩展运算符 1 2 3 4 5 let [x, ...y] = [1, 2, 3]; console.log(x, y); // 1, [2,3] let [x, y = 2] = [1]; console.log(x, y); // 1, 2 两数交换 1 2 3 4 let x = 1; let y = 2; [y, x] = [x, y]; console.log(\u0026#34;x -\u0026gt;\u0026#34;, x, \u0026#34;y -\u0026gt; \u0026#34;, y); // 2, 1 对象解构 1 2 3 4 5 6 7 8 9 10 11 12 13 let obj = { attr: \u0026#34;1\u0026#34;, func: \u0026#34;function\u0026#34;, }; let { attr, func } = obj; console.log(attr, func); // 别名 let { attr: objAttr, func } = obj; console.log(objAttr); // 默认值 let { x = 1 } = obj; console.log(x); Promise Promise 对象有三种状态 pending(待处理)、fulfilled(已履行)、rejected(被驳回) 当创建一个 Promise 对象时, 它的初始状态为 pending, 表示异步执行还未完成。 当异步执行成功时, 会调用 resolve 函数把 Promise 对象的状态改变为 fulfilled, 可通过 then 方法来获取异步操作的结果。 当异步执行异常时, 会调用 reject 函数把 Promise 对象的状态更改为 rejected, 可通过 catch 方法来处理错误. 异步操作是指在程序执行过程中, 某个操作不会立即返回结果, 而是需要一段时间的等待\n1 2 3 4 5 6 7 8 9 10 11 12 13 let promise = new Promise((resolve, reject) =\u0026gt; { //resolve(\u0026#34;请求成功\u0026#34;) reject(\u0026#34;请求失败\u0026#34;); }) .then((result) =\u0026gt; { console.log(\u0026#34;result:\u0026#34;, result); }) .catch((error) =\u0026gt; { console.log(\u0026#34;error:\u0026#34;, error); }) .finally(() =\u0026gt; { console.log(\u0026#34;异步执行结束\u0026#34;); }); 模块化开发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let attr = \u0026#34;\u0026#34;; let func = () =\u0026gt; {}; export { attr, func }; // 作为一个整体导出 export default { attr, func }; // 导入 import {attr, func} from ... // 别名 import {attr as myAttr, func} from ... // 整体导入 import obj from ... 参考文章 ES6 从入门到精通 es 6 备忘清单 ES6 新增的新特性以及用法（超详细） ","date":"2024-08-28T23:31:07+08:00","permalink":"https://xnuyoah.github.io/p/ecmascript6-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/","title":"ECMAScript6 语法学习"},{"content":"安装 前往 官网 下载并自定义安装 检查是否安装成功 1 2 3 4 node -v npm -v # 正确输出版本号即可 查看当前镜像源并修改镜像源 1 2 3 4 node get registry # 修改为阿里源 npm config set registry https://registry.npmmirror.com/ 创建 Node 应用程序生成 package.json 文件 1 npm init 遇到报错 无法加载文件，禁止运行脚本 解决方法 - 打开 Powershell\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 获取当前脚本的执行策略 Get-ExecutionPolicy # 设置脚本的执行策略 Set-ExecutionPolicy # 禁止运行所有脚本 Restricted # 所有脚本需要有效的数字签名才可运行 AllSigned # 允许运行本地创建的脚本,但从网下载的脚本则需有效的数字签名才可运行 RemoteSigned # 允许所有脚本运行 Unrestricted 内置模块 url 模块 用于解析 url、格式化 url，以及将 url 各部分相互转换的函数\n1 2 3 4 5 6 7 8 9 10 import { URL } from \u0026#34;url\u0026#34;; const myURL = new URL(\u0026#34;https://example.com:8080/pathname?name=xyz#hash\u0026#34;); const { protocol, hostname, pathname, searchParams } = myURL; console.log(protocol); // \u0026#39;https:\u0026#39; console.log(hostname); // \u0026#39;example.com\u0026#39; console.log(pathname); // \u0026#39;/pathname\u0026#39; console.log(searchParams.get(\u0026#34;name\u0026#34;)); // \u0026#39;xyz\u0026#39; path 模块 用于处理文件和目录路径\n导入 path 模块 1 import path from \u0026#34;path\u0026#34;; 返回文件名字 path.basename() 1 2 3 4 const filePath = \u0026#34;/usr/local/bin/node.js\u0026#34;; console.log(path.basename(filePath)); // 输出: \u0026#39;node.js\u0026#39; console.log(path.basename(filePath, \u0026#34;.js\u0026#34;)); // 输出: \u0026#39;node\u0026#39; 返回路径目录 path.dirname() 1 2 3 const filePath = \u0026#34;/usr/local/bin/node.js\u0026#34;; console.log(path.dirname(filePath)); // 输出: \u0026#39;/usr/local/bin\u0026#39; 返回路径扩展名 path.extname() 1 2 3 const filePath = \u0026#34;/usr/local/bin/node.js\u0026#34;; console.log(path.extname(filePath)); // 输出: \u0026#39;.js\u0026#39; 路径拼接 path.join() 1 2 3 4 5 6 const directory = \u0026#34;/usr\u0026#34;; const subDirectory = \u0026#34;local\u0026#34;; const fileName = \u0026#34;node.js\u0026#34;; console.log(path.join(directory, subDirectory, fileName)); // 输出: \u0026#39;/usr/local/node.js\u0026#39; 返回绝对路径 path.resolve() 如果路径片段前有 /，解析时会以此为根路径。\n1 2 3 4 5 console.log(path.resolve(\u0026#34;usr\u0026#34;, \u0026#34;local\u0026#34;, \u0026#34;bin/node.js\u0026#34;)); // 可能输出: \u0026#39;/current/working/directory/usr/local/bin/node.js\u0026#39; console.log(path.resolve(\u0026#34;/usr\u0026#34;, \u0026#34;/local\u0026#34;, \u0026#34;bin/node.js\u0026#34;)); // 输出: \u0026#39;/local/bin/node.js\u0026#39; 解析路径 path.parse() 1 2 3 4 5 6 7 8 9 10 11 12 const filePath = \u0026#34;/usr/local/bin/node.js\u0026#34;; const parsedPath = path.parse(filePath); console.log(parsedPath); // 输出: // { // root: \u0026#39;/\u0026#39;, // dir: \u0026#39;/usr/local/bin\u0026#39;, // base: \u0026#39;node.js\u0026#39;, // ext: \u0026#39;.js\u0026#39;, // name: \u0026#39;node\u0026#39; // } 输出当前系统分隔符 path.sep 1 console.log(path.sep); // Linux 输出: \u0026#39;/\u0026#39;, Windows 输出: \u0026#39;\\\u0026#39; fs 模块 用于文件的创建、读取、写入、删除以及其他文件相关的操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 import fs from \u0026#34;fs\u0026#34;; //创建目录 const createDir = async (path) =\u0026gt; { try { await fs.promises.mkdir(path, { recursive: true }); // recursive: true 允许递归创建多级目录 console.log(\u0026#34;目录创建成功\u0026#34;); } catch (err) { // ENOENT(Error NO ENTry) - no such file or directory (文件或目录不存在) console.error(`目录创建失败: ${err}`); } }; let dir = \u0026#34;demo/test/\u0026#34;; createDir(dir); //创建多级目录 //写入文件 const writeFile = async (path, content) =\u0026gt; { try { await fs.promises.writeFile(path, content); console.log(\u0026#34;文件写入成功\u0026#34;); } catch (err) { console.error(`文件写入失败: ${err}`); } }; let name = \u0026#34;demo.txt\u0026#34;; let path = dir + name; // dome/test/demo.txt let content = \u0026#34;this is a test code\u0026#34;; //writeFile(path, content) //追加文件 const appendFile = async (path, content) =\u0026gt; { try { await fs.promises.appendFile(path, content); console.log(\u0026#34;追加写入成功\u0026#34;); } catch (err) { console.error(`追加写入失败: ${err}`); } }; let appendContent = \u0026#34;\\nadd content\u0026#34;; //appendFile(path, appendContent) //读取文件 const readFile = async (path) =\u0026gt; { try { const data = await fs.promises.readFile(path); console.log(String(data)); } catch (err) { console.error(`文件读取失败: ${err}`); } }; //readFile(path) //检测文件或目录是否存在 /* fs.promises.constants.F_OK 检查文件是否存在 fs.promises.constants.R_OK 检查文件是否可读 fs.promises.constants.W_OK 检查文件是否可写 fs.promises.constants.X_OK 检查文件是否可执行 ENOENT(Error NO ENTry) - no such file or directory (文件或目录不存在) EEXIST - file already exists (文件已存在) EACCES - permission denied (没有足够的权限) */ const fileOrDirExist = async (path) =\u0026gt; { try { await fs.promises.access(path, fs.promises.constants.F_OK); console.error(\u0026#34;文件或目录存在\u0026#34;); } catch (err) { console.error(`文件或目录不存在: ${err}`); } }; //fileOrDirExist(\u0026#34;demo/test\u0026#34;) //fileOrDirExist(\u0026#34;demo/test/demo.txt\u0026#34;) //获取文件或目录详细信息 const fileOrDirStats = async (path) =\u0026gt; { try { let stats = await fs.promises.stat(path); //console.log(stats) // 检查是否是一个文件 if (stats.isFile()) { console.log(`${path} 是文件`); return; } // 检查是否是一个目录 if (stats.isDirectory()) { console.log(`${path} 是目录`); return; } } catch (err) { console.error(`获取文件或目录详细信息时出错: ${err}`); } }; //fileOrDirStats(\u0026#34;demo/test\u0026#34;) //fileOrDirStats(\u0026#34;demo/test/demo.txt\u0026#34;) //文件或目录重命名 const fileOrDirRename = async (oldPath, newPath) =\u0026gt; { try { await fs.promises.rename(oldPath, newPath); console.log(\u0026#34;文件或目录重命名成功\u0026#34;); } catch (err) { console.error(`文件或目录重命名失败: ${err}`); } }; //fileOrDirRename(\u0026#34;demo/test\u0026#34;, \u0026#34;demo/myTest\u0026#34;) //fileOrDirRename(\u0026#34;demo/myTest/demo.txt\u0026#34;, \u0026#34;demo/myTest/myDemo.txt\u0026#34;) //删除文件 const deleteFile = async (path) =\u0026gt; { try { await fs.promises.unlink(path); console.log(\u0026#34;文件删除成功\u0026#34;); } catch (err) { console.error(`文件删除失败: ${err}`); } }; //deleteFile(\u0026#34;demo/myTest/myDemo.txt\u0026#34;) //删除目录 const deleteDir = async (path) =\u0026gt; { try { await fs.promises.rm(path, { recursive: true }); // recursive: true 允许递归删除多级目录 console.log(\u0026#34;目录删除成功\u0026#34;); } catch (err) { console.error(`目录删除失败: ${err}`); } }; //deleteDir(\u0026#34;demo\u0026#34;) stream 模块 stream 流是一种抽象的数据处理方式，适合处理大量数据或需要逐步处理数据的场景，如文件读写、网络请求、音视频处理等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 import fs from \u0026#34;fs\u0026#34;; //创建目录 const createDir = async (path) =\u0026gt; { try { await fs.promises.mkdir(path, { recursive: true }); // recursive: true 允许递归创建多级目录 console.log(\u0026#34;目录创建成功\u0026#34;); } catch (err) { // ENOENT(Error NO ENTry) - no such file or directory (文件或目录不存在) console.error(`目录创建失败: ${err}`); } }; let dir = \u0026#34;demo/test/\u0026#34;; createDir(dir); //创建多级目录 //写入文件 /* const writeFile = async (path, content) =\u0026gt; { try { await fs.promises.writeFile(path, content) console.log(\u0026#34;文件写入成功\u0026#34;) } catch (err) { console.error(`文件写入失败: ${err}`) } } */ const writeFile = (path, content) =\u0026gt; { const writeStream = fs.createWriteStream(path); writeStream.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(`文件写入失败： ${err}`); writeStream.close(); // 出错时关闭流 }); writeStream.on(\u0026#34;finish\u0026#34;, () =\u0026gt; { console.log(\u0026#34;文件写入成功\u0026#34;); }); writeStream.write(content, \u0026#34;utf8\u0026#34;); writeStream.end(); }; let name = \u0026#34;demo.txt\u0026#34;; let path = dir + name; // demo/test/demo.txt let content = \u0026#34;this is test code\u0026#34;; //writeFile(path, content) //追加文件 /* const appendFile = async (path, content) =\u0026gt; { try { await fs.promises.appendFile(path, content) console.log(\u0026#34;追加写入成功\u0026#34;) } catch (err) { console.error(`追加写入失败: ${err}`) } } */ const appendFile = (path, content) =\u0026gt; { const appendStream = fs.createWriteStream(path, { flags: \u0026#34;a\u0026#34; }); appendStream.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(`追加写入失败 ${err}`); writeStream.close(); // 出错时关闭流 }); appendStream.on(\u0026#34;finish\u0026#34;, () =\u0026gt; { console.log(\u0026#34;追加写入成功\u0026#34;); }); appendStream.write(content, \u0026#34;utf8\u0026#34;); appendStream.end(); }; let appendContent = \u0026#34;\\nadd code\u0026#34;; //appendFile(path, appendContent) //读取文件 /* const readFile = async (path) =\u0026gt; { try { const data = await fs.promises.readFile(path) console.log(String(data)) } catch (err) { console.error(`文件读取失败: ${err}`) } } */ const readFile = (path) =\u0026gt; { const readStream = fs.createReadStream(path); let content = \u0026#34;\u0026#34;; readStream.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { console.log(chunk); // chunk是指在流中传输的数据块 content += chunk.toString(\u0026#34;utf8\u0026#34;); // 将Buffer转换为UTF-8编码的字符串 }); readStream.on(\u0026#34;end\u0026#34;, () =\u0026gt; { console.log(content); }); readStream.on(\u0026#34;error\u0026#34;, (err) =\u0026gt; { console.error(`文件读取失败: ${err}`); }); }; //readFile(path) //检测文件或目录是否存在 /* fs.promises.constants.F_OK 检查文件是否存在 fs.promises.constants.R_OK 检查文件是否可读 fs.promises.constants.W_OK 检查文件是否可写 fs.promises.constants.X_OK 检查文件是否可执行 ENOENT(Error NO ENTry) - no such file or directory (文件或目录不存在) EEXIST - file already exists (文件已存在) EACCES - permission denied (没有足够的权限) */ const fileOrDirExist = async (path) =\u0026gt; { try { await fs.promises.access(path, fs.promises.constants.F_OK); console.error(\u0026#34;文件或目录存在\u0026#34;); } catch (err) { console.error(`文件或目录不存在: ${err}`); } }; //fileOrDirExist(\u0026#34;demo/test\u0026#34;) //fileOrDirExist(\u0026#34;demo/test/demo.txt\u0026#34;) //获取文件或目录详细信息 const fileOrDirStats = async (path) =\u0026gt; { try { let stats = await fs.promises.stat(path); //console.log(stats) // 检查是否是一个文件 if (stats.isFile()) { console.log(`${path} 是文件`); return; } // 检查是否是一个目录 if (stats.isDirectory()) { console.log(`${path} 是目录`); return; } } catch (err) { console.error(`获取文件或目录详细信息时出错: ${err}`); } }; //fileOrDirStats(\u0026#34;demo/test\u0026#34;) //fileOrDirStats(\u0026#34;demo/test/demo.txt\u0026#34;) //文件或目录重命名 const fileOrDirRename = async (oldPath, newPath) =\u0026gt; { try { await fs.promises.rename(oldPath, newPath); console.log(\u0026#34;文件或目录重命名成功\u0026#34;); } catch (err) { console.error(`文件或目录重命名失败: ${err}`); } }; //fileOrDirRename(\u0026#34;demo/test\u0026#34;, \u0026#34;demo/myTest\u0026#34;) //fileOrDirRename(\u0026#34;demo/myTest/demo.txt\u0026#34;, \u0026#34;demo/myTest/myDemo.txt\u0026#34;) //删除文件 const deleteFile = async (path) =\u0026gt; { try { await fs.promises.unlink(path); console.log(\u0026#34;文件删除成功\u0026#34;); } catch (err) { console.error(`文件删除失败: ${err}`); } }; //deleteFile(\u0026#34;demo/myTest/myDemo.txt\u0026#34;) //删除目录 const deleteDir = async (path) =\u0026gt; { try { await fs.promises.rm(path, { recursive: true }); // recursive: true 允许递归删除多级目录 console.log(\u0026#34;目录删除成功\u0026#34;); } catch (err) { console.error(`目录删除失败: ${err}`); } }; //deleteDir(\u0026#34;demo\u0026#34;) os 模块 与操作系统交互\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import os from \u0026#34;os\u0026#34;; //bytes转换为GB const bytesToGB = (bytes) =\u0026gt; (bytes / (1024 * 1024 * 1024)).toFixed(2); console.log(\u0026#34;内核版本:\u0026#34;, os.version()); console.log(\u0026#34;操作系统类型:\u0026#34;, os.type()); console.log(\u0026#34;系统架构:\u0026#34;, os.arch()); console.log(\u0026#34;主机名:\u0026#34;, os.hostname()); console.log(\u0026#34;总内存(GB):\u0026#34;, bytesToGB(os.totalmem())); console.log(\u0026#34;空闲内存(GB):\u0026#34;, bytesToGB(os.freemem())); console.log(\u0026#34;CPU核心数:\u0026#34;, os.cpus().length); console.log(\u0026#34;当前用户的主目录:\u0026#34;, os.homedir()); console.log(\u0026#34;当前用户的信息:\u0026#34;, os.userInfo()); 自动重启工具 nodemon 安装 1 npm i nodemon -g 运行 1 nodemon xxx.js package.json 配置 1 2 3 \u0026#34;script\u0026#34;: {\u0026#34;dev\u0026#34;: nodemon xxx.js} # 执行 node run dev 参考文章 node.js 快速入门 node.js 安装及环境配置超详细教程【Windows 系统安装包方式】 Node.js 下载安装及环境配置教程【超详细】 nvm 备忘清单 npm 备忘清单 package.json 备忘清单 ","date":"2024-08-28T22:34:54+08:00","permalink":"https://xnuyoah.github.io/p/node-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","title":"Node 安装、使用及模块介绍"},{"content":"安装 Windows 前往 Miniconda3 官网 安装成功后将以下添加环境变量(修改默认安装路径) /path/to/miniconda3 /path/to/miniconda3/Scripts /path/to/miniconda3/Library/bin 检查是否安装成功 1 conda -V 查看 conda 配置信息 1 conda info # conda info --show 修改 python 环境生成目录并添加镜像 找到 .condarc 文件并修改 envs_dirs 值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud envs_dirs: - /path/to/miniconda3/envs Linux 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 下载 wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/Downloads/Miniconda3-latest-Linux-x86_64.sh # 添加执行权限 chmod +x Miniconda3-latest-Linux-x86_64.sh # 安装 ./Miniconda3-latest-Linux-x86_64.sh # 激活环境变量 source ~/.bashrc # 检查是否安装成功 conda -V pip 配置镜像 1 2 3 4 5 # 设置全局永久清华下载源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple # 升级pip pip install pip -U 删除 pip 安装的所有第三方包 1 2 3 4 5 6 7 8 # 导出所有安装包 pip freeze \u0026gt; requirements.txt # 删除所有第三方库 pip uninstall -r requirements.txt -y # 查看pip安装库 pip list conda 常用命令 1 2 3 4 5 6 7 8 9 10 11 12 # 新建环境 conda create --name \u0026lt;env_name\u0026gt; python=\u0026lt;python_version\u0026gt; -y # 删除环境 conda env remove --name \u0026lt;env_name\u0026gt; # 查看所有的环境 conda env list conda info --envs # 激活conda环境 source activate \u0026lt;env_name\u0026gt; 参考文章 修改 conda 环境安装路径，解决环境默认安装在 C 盘问题 Linux 环境下 Miniconda3 的安装和使用 Miniconda 安装及使用 for windows（保姆级教程） Conda 备忘清单 pip 使用国内镜像源（附加全局修改） ","date":"2024-08-26T21:02:02+08:00","permalink":"https://xnuyoah.github.io/p/miniconda-%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%85%8D%E7%BD%AE/","title":"Miniconda 的安装、使用及配置"},{"content":"安装 Linux 1 2 3 # Ubuntu 22.04 sudo apt update sudo apt install git Windows 前往 Git 官网 下载最新版本 默认选项安装即可 设置用户/邮箱 1 2 3 4 # 查看 git 配置项 git config --list git config --global user.name \u0026#34;username\u0026#34; git config --global user.email \u0026#34;email\u0026#34; 生成 ssh 密钥 生成单个密钥 1 2 3 4 ssh-keygen -t rsa -b 4096 -C \u0026#34;email\u0026#34; # 按三下回车, 得到 id_rsa, id_rsa.pub 文件 # 路径: home/[user]/.ssh 或 c:/User/[user]/.ssh 多个密钥 命令 1 ssh-keygen -t rsa -C \u0026#34;email\u0026#34; -f /path/to/.ssh/id_rsa_\u0026lt;后缀\u0026gt; 新建 config 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 # 配置 Github Host github.com HostName ssh.github.com IdentityFile /path/to/.ssh/id_rsa_github PreferredAuthentications publickey User \u0026lt;username\u0026gt; # 配置 gitee Host gitee.com HostName gitee.com IdentityFile /path/to/.ssh/id_rsa_gitee PreferredAuthentications publickey User \u0026lt;username\u0026gt; 校验 1 2 ssh -T git@github.com ssh -T git@gitee.com Git 三个区域 工作区 -\u0026gt; 开发者编写及修改代码区域 暂存区 -\u0026gt; 临时存放文件的修改，工作区的文件提交及回滚交互 本地仓库 -\u0026gt; 存放代码及数据位置，包含所有提交版本。HEAD 指向最新提交版本 远程仓库 -\u0026gt; 与本地仓库链接的 git 仓库，用于代码交换 Git 常用命令 配置相关 查看配置 1 2 3 4 5 # 全局 git config --global --list # 非全局 git config --list 添加/删除配置 1 2 3 4 5 6 7 8 9 10 11 # 添加 # 全局 git config --global user.name \u0026#34;username\u0026#34; # 非全局 git config user.name \u0026#34;username\u0026#34; # 删除 # 全局 git config --global --unset user.name # 非全局 git config --unset user.name 本地仓库相关 创建本地仓库 1 git init 克隆远程仓库 1 git clone xxx.git 查看当前仓库状态 1 git status 将修改从工作区提交到暂存区 1 2 3 4 5 6 7 8 # 单文件 git add 文件名 # 所有 git add . # 文件在工作区被删除, 同步到暂存区 git rm 文件名 将修改提交到仓库 1 2 3 4 git commit 文件名 -m \u0026#34;提交信息\u0026#34; # 修改提交信息 git commit --amend -m \u0026#34;新的提交信息\u0026#34; 提交记录 查看提交记录 1 git log 远程仓库 添加远程仓库 1 git remote add origin xxx.git 显示当前远程仓库信息 1 git remote -v 删除已绑定的远程仓库 1 git remote rm origin 切换远程仓库地址 1 git remote set-url origin xxx.git 拉取远程分支到本地 1 git checkout -b 分支名 origin/分支名 关联本地和远程分支 1 git branch --set-upstream-to=origin/分支名 分支名 分支相关 查看所有分支 1 git branch -l 查看当前分支 1 git branch 创建分支 1 git branch 分支名 切换分支 1 git checkout 分支名 创建并切换分支 1 git checkout -b 分支名 删除分支 1 2 git branch -d 分支名 # 分支没有合并的提交, 推荐使用 -D Git Commit 提交规范 vscode 插件推荐 - git-commit-plugin\n提交信息 1 2 3 4 5 \u0026lt;type\u0026gt;(scope?): \u0026lt;description\u0026gt; \u0026lt;blank line\u0026gt; (body?) \u0026lt;blank line\u0026gt; \u0026lt;footer(s)?\u0026gt; 提交类型 type summary description build 项目构建系统 修改依赖库、外部接口或者升级 Node 版本等 chore 非业务性代码处理 修改构建流程或者工具配置等 ci 持续集成相关文件修改 修改 Travis、Jenkins 等工作流配置 docs 文档变更 修改 README 文件、API 文档等 feat 添加新功能 新特性添加，新功能添加 fix 错误修复 Bug 修复，代码功能错误逻辑修复 perf 性能优化 提升代码的性能、减少内存占用等 refactor 代码重构 修改代码结构、变量名、函数名等但不修改功能逻辑 revert 版本回滚 回滚到以前的版本，撤销之前的提交 style 代码样式调整 调整缩进、空格、空行等 test 更新测试 添加、删除、修改代码的测试用例等 release 版本更新 通常包括版本号的更新，以及更新 CHANGELOG workflow 工作流变更 改变了需求分析或者开发流程上的某些步骤等 示例 commit message description chore: init 初始化项目 fix: value.length -\u0026gt; values.length value 变量修改为 values feat: support typescript 新增 typescript 支持 style(tools): code 修改 tools 代码样式 refactor: xxx 重构 xxx perf(utils): function random 优化 utils 的 random 函数 docs: home.md 添加 home.md 参考文章 约定式提交 Git 备忘清单 ","date":"2024-08-26T17:07:47+08:00","permalink":"https://xnuyoah.github.io/p/git-%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/","title":"Git 的安装、配置以及提交规范"},{"content":"Hugo 下载 前往 Hugo Tags 选择 hugo_extended_xxx_windows-amd64.zip 版本下载后并解压\nHugo 解压安装 win + s 搜索 环境变量 点击 编辑环境变量，依次打开 环境变量 \u0026gt; 系统变量 \u0026gt; Path \u0026gt; 新建 并将 Hugo 解压路径添加进去\n查看 hugo 版本 1 2 3 hugo version # 安装成功输出示例: hugo xxx 搭建个人博客 创建博客 打开 cmd 窗口 1 hugo new site blogs 本地预览 1 2 3 hugo server -D # 访问地址: http://localhost:1313/ 配置主题 配置主题时对主题进行修改可能会产生冲突，可以先 fork 主题仓库到自己的账户，使用 git submodule 对修改后的主题进行维护\n使用 git submodule 1 2 3 4 5 6 cd blogs git init git submodule https://github.com/xnuyoah/hugo-theme-stack themes/hugo-theme-stack # 同步主题修改 git submodule update --remote 复制 exampleSite 目录到主目录下然后修改配置 1 cp -rf themes/hugo-theme-stack/exampleSite/* ./ 修改配置文件 hugo.yaml 文件配置项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 baseurl: https://example.com # 网站链接 languageCode: zh-cn # 语言 theme: hugo-theme-stack # 主题名 paginate: 3 # 分页数 title: xxx # 网站标题 copyright: xxx # 页脚 copyright DefaultContentLanguage: zh-cn # 默认语言 hasCJKLanguage: true # 设置默认语言为 zh-cn 需要将此设为 true languages: # 语言配置 zh-cn: languageName: 简体中文 title: xxx # 标题 weight: 2 params: description: xxx # 描述 params: mainSections: - post # 博客文章识别目录名 favicon: static/favicon.ico # 网站图标 footer: # 页脚配置 since: 2024 customText: xxx dateFormat: # 时间格式配置 published: Jan 02, 2006 lastUpdated: Jan 02, 2006 15:04 MST sidebar: subtitle: xxx # 子标题 avatar: src: img/avatar.png # 头像 article: license: enabled: false # 是否显示 license default: Licensed under CC BY-NC-SA 4.0 page 目录修改 删除目录 about，link 修改 archives，search 目录下的 title 值为中文 注释非必要提示 注释 themes \u0026gt; hugo-theme-stack \u0026gt; layouts \u0026gt; footer 下 footer.html 部分内容\n1 2 3 4 5 \u0026lt;!-- {{- $Generator := `\u0026lt;a href=\u0026#34;https://gohugo.io/\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt;Hugo\u0026lt;/a\u0026gt;` -}} {{- $Theme := printf `\u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;https://github.com/CaiJimmy/hugo-theme-stack\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; data-version=\u0026#34;%s\u0026#34;\u0026gt;Stack\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt;` $ThemeVersion -}} {{- $DesignedBy := `\u0026lt;a href=\u0026#34;https://jimmycai.com\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;\u0026gt;Jimmy\u0026lt;/a\u0026gt;` -}} {{ T \u0026#34;footer.builtWith\u0026#34; (dict \u0026#34;Generator\u0026#34; $Generator) | safeHTML }} \u0026lt;br /\u0026gt; {{ T \u0026#34;footer.designedBy\u0026#34; (dict \u0026#34;Theme\u0026#34; $Theme \u0026#34;DesignedBy\u0026#34; $DesignedBy) | safeHTML }} --\u0026gt; 创建文章 使用 hugo 创建文章，生成 MarkDown 文档 1 hugo new post/xxx/index.md MarkDown 文档元数据 categories：分类 tags：标签 image：文章封面 draft：是否草稿 预览文章 1 hugo server -D Github 部署 更改远程仓库地址 1 2 3 git remote -v git remote set-url origin xxx.git git remote -v 新建特殊仓库 xxx.github.io 部署博客 使用命令 hugo -D 生成 public 目录\n上传 public 目录 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/xxx/xxx.git git push -u origin main Pages 部署 配置完成访问 https://xxx.github.io\n新建仓库存放源数据并配置 Github Action 自动部署 添加 .gitignore 1 2 3 public resources .hugo_build.lock 创建部署 token 创建部署 token 并勾选 repo，workflow 选项 前往特殊仓库 xxx.github.io 设置部署 token 创建 .github/workflows/xxx.yaml 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: hugo deploy on: push: branches: - main # 设置部署分支 jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true # 获取 hugo themes fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.133.0\u0026#34; # hugo 版本 extended: true # 启用 extended - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.token变量名 }} EXTERNAL_REPOSITORY: github名/仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 参考文章 使用 Hugo + Github Pages 部署个人博客 【Hugo】Hugo + Github 免费部署自己的博客 Hugo + GitHub Action，搭建你的博客自动发布系统 Hugo 博客引入 Giscus 评论系统 ","date":"2024-08-25T14:39:01+08:00","permalink":"https://xnuyoah.github.io/p/%E4%BD%BF%E7%94%A8-hugo--github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2windows-%E7%89%88%E6%9C%AC/","title":"使用 Hugo + Github Pages 搭建个人博客(windows 版本)"}]